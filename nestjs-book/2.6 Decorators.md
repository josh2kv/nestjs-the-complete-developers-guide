# ë°ì»¤ë ˆì´í„°

- Class, Method, Accessor, Property, Parametorì— ì ìš© ê°€ëŠ¥
- ê° ìš”ì†Œì˜ ì„ ì–¸ë¶€ ì•ì— `@`ë¡œ ì‹œì‘í•˜ëŠ” decoratorë¥¼ ì„ ì–¸í•˜ë©´ decoratorë¡œ êµ¬í˜„ëœ ì½”ë“œë¥¼ í•¨ê»˜ ì‹¤í–‰í•¨
- `@expression`: expressionì€ ë°ì»¤ë ˆì´íŒ…ëœ ì„ ì–¸(ë°ì»¤ë ˆì´í„°ê°€ ì„ ì–¸ë˜ëŠ” í´ë˜ìŠ¤, ë©”ì„œë“œ ë“±)ì— ëŒ€í•œ ì •ë³´ì™€ í•¨ê»˜ ëŸ°íƒ€ì„ì— í˜¸ì¶œë˜ëŠ” **function**

## ë°ì»¤ë ˆì´í„°ë¥¼ ì„ ì–¸í•˜ê³  ì‚¬ìš©í•˜ê¸°

```ts
function deco(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('1ï¸âƒ£ ë°ì½”ë ˆì´í„°ê°€ í‰ê°€ë¨');
}

class TestClass {
    @deco()
    test() {
        console.log('2ï¸âƒ£ test() í˜¸ì¶œë¨');
    }
}

const t = new TestClass()
t.test()
```

## ë°ì»¤ë ˆì´í„°ì— ì¸ìˆ˜ ì „ë‹¬í•˜ê¸°

- ë°ì»¤ë ˆì´í„°ì— ì¸ìˆ˜ë¥¼ ë„˜ê²¨ì„œ ë°ì»¤ë ˆì´í„°ì˜ ë™ì‘ì„ ë³€ê²½í•˜ê³  ì‹¶ë‹¤ë©´? -> ë°ì»¤ë ˆì´í„°ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜(ë°ì»¤ë ˆì´í„° íŒ©í† ë¦¬)ë¥¼ ì‚¬ìš©

```ts
function deco(value: string) {
    console.log('1ï¸âƒ£ ë°ì½”ë ˆì´í„°ê°€ í‰ê°€ë¨');
    return function (target: any, propertyKey: string, descriptor: propertyDescriptor) {
        console.log('2ï¸âƒ£ value', value);
    }
}

class TestClass {
    @deco('Hello')
    test() {
        console.log('3ï¸âƒ£ test() í˜¸ì¶œë¨');
    }
}

const t = new TestClass()
t.test()
```

## ì—¬ëŸ¬ ë°ì»¤ë ˆì´í„°ë¥¼ í•œë²ˆì— ì ìš©í•˜ê¸°

- ì—¬ëŸ¬ê°œì˜ ë°ì»¤ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ìˆ˜í•™ì—ì„œì˜ í•¨ìˆ˜ í•©ì„±ê³¼ ê°™ì´ ë°ì»¤ë ˆì´í„°ê°€ í•©ì„±ë¨
- ìœ„ì—ì„œ ì•„ë˜ë¡œ **evaluate**ëœ ë‹¤ìŒ ì•„ë˜ì—ì„œ ìœ„ë¡œ **call**ë¨

```ts
function first() {
    console.log("1ï¸âƒ£ first(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("4ï¸âƒ£ first(): called");
    };
}

function second() {
    console.log("2ï¸âƒ£ second(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("3ï¸âƒ£ second(): called");
    };
}

class ExampleClass {
    @first()
    @second()
    method() {
        console.log('method is called');
    }
}
```

## ë°ì»¤ë ˆì´í„°ì˜ ì¢…ë¥˜

| ë°ì½”ë ˆì´í„°      | ì—­í•               | í˜¸ì¶œì‹œ ì „ë‹¬ë˜ëŠ” ì¸ì                               | ì„ ì–¸ ë¶ˆê°€ëŠ¥í•œ ìœ„ì¹˜                     |
|------------|-----------------|-------------------------------------------|--------------------------------|
| í´ë˜ìŠ¤ ë°ì½”ë ˆì´í„°  | í´ë˜ìŠ¤ì˜ ì •ì˜ë¥¼ ì½ê±°ë‚˜ ìˆ˜ì • | (constructor)                             | d.ts íŒŒì¼, declare í´ë˜ìŠ¤           |
| ë©”ì„œë“œ ë°ì½”ë ˆì´í„°  | ë©”ì„œë“œì˜ ì •ì˜ë¥¼ ì½ê±°ë‚˜ ìˆ˜ì • | (target, propertyKey, propertyDescriptor) | d.ts íŒŒì¼, declare í´ë˜ìŠ¤, ì˜¤ë²„ë¡œë“œ ë©”ì„œë“œ |
| ì ‘ê·¼ì ë°ì½”ë ˆì´í„°  | ì ‘ê·¼ìì˜ ì •ì˜ë¥¼ ì½ê±°ë‚˜ ìˆ˜ì • | (target, propertyKey, propertyDescriptor) | d.ts íŒŒì¼, declare í´ë˜ìŠ¤           |
| ì†ì„± ë°ì½”ë ˆì´í„°   | ì†ì„±ì˜ ì •ì˜ë¥¼ ì½ìŒ      | (target, propertyKey)                     | d.ts íŒŒì¼, declare í´ë˜ìŠ¤           |
| ë§¤ê°œë³€ìˆ˜ ë°ì½”ë ˆì´í„° | ë§¤ê°œë³€ìˆ˜ì˜ ì •ì˜ë¥¼ ì½ìŒ    | (target, propertyKey, parameterIndex)     | d.ts íŒŒì¼, declare í´ë˜ìŠ¤           |

### Class Decorators

```ts
function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    reportingURL = "http://www.example.com";
  };
}

@reportableClassDecorator
class BugReport {
  type = "report";
  title: string;

  constructor(t: string) {
    this.title = t;
  }
}

const bug = new BugReport("Needs dark mode");
console.log(bug);
```

- `{ new (...args: any[]): {} }`: constructor functionì˜ signature
  - `reportableClassDecorator` functionì„ ì‚¬ìš©í•˜ì—¬ decorateë˜ëŠ” í´ë˜ìŠ¤ëŠ” ë°˜ë“œì‹œ ì„ì˜ typeì¸ ì„ì˜ ê°œì˜ argumentë¥¼ ë°›ì•„ objectë¥¼ returní•˜ëŠ” constructorë¥¼ ê°€ì ¸ì•¼ í•¨ì„ ì˜ë¯¸
  - `{ new (...) }`: This defines a constructor function signature, indicating that the class being decorated should have a constructor.
  - `...args: any[]`: This specifies that the constructor can take any number of arguments of any type.
  - `: {}`: This specifies that the constructor should return an object of any type.

- ğŸ’¡ TS Playgroundë¥¼ í†µí•´ JSì½”ë“œë¥¼ ë³´ë©´ Class(`BugReport`)ì˜ typeì´ ë³€ê²½ë˜ëŠ” ê²ƒì´ ì•„ë‹˜. ì‹¤ì œë¡œëŠ” íƒ€ì…ì‹œìŠ¤í…œì€ `reportingURL`ì„ ì¸ì‹í•˜ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì— `bug.reportingURL`ì²˜ëŸ¼ ì§ì ‘ ì‚¬ìš© ë¶ˆê°€

### Method Decorators

- ê·¸ëƒ¥ errorë¥¼ throwí•˜ë˜ `hello()`ë¥¼ logí•˜ë„ë¡ ë°”ê¿ˆ

```ts
function HandleError() {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('target: ', target) // Greeter: {} 
    console.log('propertyKey: ', propertyKey) // "hello"
    console.log('descriptor', descriptor) // { "writable": true, "enumerable": false, "configurable": true }  

    const method = descriptor.value;
    console.log('method: ', method)
    descriptor.value = function() {
      try {
        method();
      } catch (e) {
        // ì—ëŸ¬ í•¸ë“¤ë§ ë¡œì§ êµ¬í˜„
        console.log(e);
      }
    }
  };
}

class Greeter {
  @HandleError()
  hello() {
    throw new Error('í…ŒìŠ¤íŠ¸ ì—ëŸ¬');
  }
}

const t = new Greeter();
t.hello();
```

> ğŸ“ Aspect-Oriented Programming(AOP)
> : a programming paradigm that aims to improve the modularity and maintainability of software systems by separating cross-cutting concerns, such as logging, security, and error handling, from the core business logic.

```ts
// original: business logicë§Œ ë“¤ì–´ìˆìŒ
class Calculator {
  add(a: number, b: number) {
    return a + b;
  }

  subtract(a: number, b: number) {
    return a - b;
  }
}

// logë¥¼ ì¶”ê°€: business logicê³¼ cross-cutting concerns(log)ì´ ì„ì—¬ ìˆìŒ
class Calculator {
  add(a: number, b: number) {
    console.log(`Adding ${a} and ${b}`);
    const result = a + b;
    console.log(`Result: ${result}`);
    return result;
  }

  subtract(a: number, b: number) {
    console.log(`Subtracting ${b} from ${a}`);
    const result = a - b;
    console.log(`Result: ${result}`);
    return result;
  }
}

// AOPë¡œ refactorëœ ì½”ë“œ: business logicê³¼ cross-cutting concernsë¥¼ ë¶„ë¦¬í•˜ì—¬ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì´ê³  ëª¨ë“ˆì„±ì„ ë†’ì„ 
class LoggingAspect {
  before(target: any, methodName: string, args: any[]) {
    console.log(`Calling method ${methodName} with args ${JSON.stringify(args)}`);
  }

  after(target: any, methodName: string, result: any) {
    console.log(`Method ${methodName} returned ${result}`);
  }
}

function loggable() {
  return function(target: any, methodName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function(...args: any[]) {
      const aspect = new LoggingAspect();
      aspect.before(target, methodName, args);

      const result = originalMethod.apply(this, args);

      aspect.after(target, methodName, result);

      return result;
    };

    return descriptor;
  };
}

class Calculator {
  @loggable()
  add(a: number, b: number) {
    return a + b;
  }

  @loggable()
  subtract(a: number, b: number) {
    return a - b;
  }
}

``
